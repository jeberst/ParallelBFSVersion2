#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble

%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\let\textquotedbl="
\usepackage{pgfplots}
\end_preamble
\options conference
\use_default_options false
\begin_modules
enumitem
\end_modules
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Parallel Breadth First Search for Scale-Free Social Network Graphs
\end_layout

\begin_layout Author
\begin_inset Flex Flex:Author Name
status open

\begin_layout Plain Layout
James Ihrig
\end_layout

\end_inset

 
\begin_inset Flex Flex:Author Affiliation
status open

\begin_layout Plain Layout
University of Central Florida
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex Flex:Author Name
status open

\begin_layout Plain Layout
Josh Eberst
\end_layout

\end_inset

 
\begin_inset Flex Flex:Author Affiliation
status collapsed

\begin_layout Plain Layout
University of Central Florida
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex Flex:Author Name
status collapsed

\begin_layout Plain Layout
Johnathan Pecoraro
\end_layout

\end_inset

 
\begin_inset Flex Flex:Author Affiliation
status collapsed

\begin_layout Plain Layout
University of Central Florida
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Graphical representations are one of the most commonly used abstractions
 to model large networks.
 Social media networks like Facebook and Twitter contain massive scale free
 networks with billions of nodes.
 The scale free nature of the connections between nodes presents several
 challenges to the performance of traditional searching algorithms.
 In this paper, we present three implementations of Parallel Breadth First
 Search algorithms on scale free networks without the use of specialized
 hardware.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Graph abstractions are commonly used in large scale network analysis 
\begin_inset CommandInset citation
LatexCommand cite
key "Yoo:2005:SDP:1105760.1105790"

\end_inset

.
 With the proliferation of "Big Data" applications, parallelized versions
 of common graph analysis algorithms have a very high demand.
 
\end_layout

\begin_layout Standard
Many graph analysis problems make use of Breadth First Search (BFS), as
 the efficiency of the algorithm scales linearly with the number of nodes
 and edges.
 
\end_layout

\begin_layout Standard
Parallelizing Breadth First Search algorithms offers an excellent opportunity
 to increase the efficiency of this common graph analysis technique.
 However, scale free networks such as those created by social media connections
 are challenging to parallelize efficiently as the high distribution of
 edges to a few nodes is difficult to balance in memory 
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset

.
 Our research is targeted at the implementation of three variations of Parallel
 Breadth First Search algorithms without the use of specialized hardware
 on scale free networks.
 The first algorithm, Parallel Breadth First Search with Partitioning (PPBFS),
 was originally designed to improve BFS performance in distributed memory
 architectures used by many modern supercomputers.
 Our implementation will specifically apply applied this solution to scale
 free networks, which was left as future work by the original authors.
 However, as we are did not implementing specialized hardware, our research
 will was be performed without the use of a distributed memory architecture.
\end_layout

\begin_layout Standard
The second algorithm we will implement, Multithreaded Breadth First Search
 (MTBFS), is designed to support fine-grained, low overhead synchronization
 in a massively multithreaded system 
\begin_inset CommandInset citation
LatexCommand cite
key "Yoo:2005:SDP:1105760.1105790"

\end_inset

.
 This algorithm will be used for gauging the performance of PPBFS, as MTBFS
 was intended to support scale free graphs.
 Since the focus of MTBFS is on increased parallelism through multi threading,
 the differences between the Cray MTA-2 system MTBFS was designed for and
 a standard multi-core CPU should be less drastic than the shift from the
 distributed memory architecture used by PPBFS.
 Memory access by BFS and other graph algorithms is typically fine-grained
 and irregular.
 This leads to poor cache performance, especially in parallel versions of
 BFS as parallelization relies heavily on the cache performance.
 Some performance improvements can be made, but they can not be sufficiently
 generalized since cache performance depends largely on the structure of
 the graph 
\begin_inset CommandInset citation
LatexCommand cite
key "Yoo:2005:SDP:1105760.1105790"

\end_inset

.
\end_layout

\begin_layout Standard
The final algorithm we implemented is a level synchronous breadth-first
 search.
 This implementation of this algorithm forces the threads to process the
 graph iteratively during the breadth first search.
 The iterative nature of this algorithm ensures the same node is not visited
 multiple times.
 The paper uses this algorithm as part of their hybrid breadth-first search
 solution.
\end_layout

\begin_layout Standard
We will compare all of these algorithms with the sequential version of BFS
 across two datasets.
 One dataset will be a sufficiently large import of a Facebook social network,
 and the other a generic dataset based on internet architecture.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Subsection*
A Scalable Distributed Parallel Breadth First Search Algorithm on BlueGene/L
\begin_inset CommandInset citation
LatexCommand cite
key "Yoo:2005:SDP:1105760.1105790"

\end_inset


\end_layout

\begin_layout Standard
This paper talks about searching networks that are too large to fit into
 memory of a single machine.
 To handle this, it divides the graph into partitions where each node processes
 a set of vertices assigned to it.
 If it finds a vertex that does not belong to it, the node that owns it
 is notified.
 One major drawback this approach seems to have is that it waits for all
 processes to reach the same level before moving on.
 While this is important to truly follow a breadth first pattern, it may
 not be necessary to limit it in this way.
\end_layout

\begin_layout Subsection*
Designing Multithreaded Algorithms for Breath First search and st-connectivity
 on the Cray MTA-2
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset


\end_layout

\begin_layout Standard
The Multithreaded BFS algorithm implemented by Bader and Madduri will serve
 as our baseline parallel BFS algorithm.
 Although initially implemented on a massively multithreaded shared memory
 system without a data cache, we believe the fine-grained parallelization
 of this algorithm will still perform efficiently in a single CPU multi-core
 system.
 We have chosen this algorithm to serve as baseline parallelized implementation
 because it was specifically designed for the traversal of large scale-free
 graphs similar to those used in our benchmarks.
\end_layout

\begin_layout Subsection*
Parallel Breadth First Search on Distributed Memory Systems
\begin_inset CommandInset citation
LatexCommand cite
key "Buluc:2011:PBS:2063384.2063471"

\end_inset


\end_layout

\begin_layout Standard
The partitioning Parallel Breadth First Search algorithm for distributed
 memory systems implemented by Buluc and Madduri extends the research performed
 by Yoo on the Scalable Distributed Parallel Breadth First Search, and highlight
s inefficiencies in the supporting structure of the other research.
 This research provided prior work summaries and criticism on the two algorithms
 we will adopt, but implementing the improvements made here is outside the
 scope of our research.
\end_layout

\begin_layout Subsection*
Efficient Parallel Graph Exploration on Multi-Core CPU and GPU
\begin_inset CommandInset citation
LatexCommand cite
key "EfficientparallelGraphExplorationOnMultiCoreCPUAndGPU"

\end_inset


\end_layout

\begin_layout Standard
The breadth-first search algorithm presented in this paper was proposed
 by Sungpack Hong, Tayo Oguntebi, and Kunle Olukotun.
 Their algorithm uses a hybrid approach to dynamically determine the best
 search method to use.
 They combine a level synchronous approach with a partitioning approach.
 For their combined approach, they determine whether to use a queue based
 search or an array based search based on criteria observed from the graph.
\end_layout

\begin_layout Section
Technical Approach
\end_layout

\begin_layout Standard
Our projects technical approach focuses on comparing the graph traversal
 time of the three versions of the BFS algorithm.
 The original implementations of our parallel BFS algorithms were intended
 for use on super-computing hardware.
 The reason we have implemented multiple parallel BFS algorithms is to allow
 for additional performance comparisons between the algorithms, since they
 are abstracted away from their specialized hardware.
 Additionally all of our parallel algorithms will have their performance
 compared with a traditional sequential implementation of BFS.
\end_layout

\begin_layout Standard
The performance comparison of the algorithms will be determined by the amount
 of time each algorithm takes to fully traverse every node in two scale-free
 graphing benchmarks.
 We have implemented our solution using a third party application, NodeXL
\begin_inset CommandInset citation
LatexCommand cite
key "AnalyzingSocialMediaNetworksWithNodeXL"

\end_inset

, to generate large scale-free graphs within our application.
 The NodeXL program is an open source application written in the C# language.
 In general, it is used as a network visualization tool which gives users
 the ability to view a graph’s connectivity on a graphical interface.
 Additionally, there is a social network plugin for the NodeXL application
 which provides the capability of importing a social network graph from
 Facebook.
 We have utilized the class libraries for NodeXL and the associated social
 network plugin within our application to assist with the generation of
 the graphs.
\end_layout

\begin_layout Standard
Our first benchmark will be based on a graph of a sufficiently large social
 network imported through the use of the Facebook social network plugin
 for NodeXL.
 Our second benchmark is a based on an internet network dataset with over
 124,000 nodes and 200,000 edges.
 Both of these datasets will be imported using NodeXL into a graph consumable
 by the algorithms.
 These benchmarks should both be sufficiently large to incur the cache performan
ce challenges associated with many parallel BFS solutions.
\end_layout

\begin_layout Standard
We had intended to include the generic scale-free graph generated by the
 social network data generator GDBench 
\begin_inset CommandInset citation
LatexCommand cite
key "BenchmarkingDatabaseSystemsForSocialNetworkApplications"

\end_inset

.
 The GDBench tool is capable of generating scale-free graphs with millions
 of nodes, and saving it in a common GraphML format, but the graphs generated
 by the tool were significantly disjoint.
 This made inclusion of the benchmark difficult as over half the nodes were
 unreachable.
\end_layout

\begin_layout Section
Technical Details
\end_layout

\begin_layout Standard
All of the algorithms we have implemented were originally implemented on
 specialized supercomputing hardware.
 A difference in our approach is to implement these algorithms on a single
 CPU with multiple cores.
 Two of the algorithms, MTBFS and LSBFS will be implemented as closely as
 possible to their original design on the super computing hardware.
 The PPBFS algorithm will be significanly modified from its original design
 for distributed computing hardware.
 
\end_layout

\begin_layout Subsection*
Parallel With Partitioning BFS (PPBFS)
\end_layout

\begin_layout Standard
The original algorithm used as a reference for our project was implemented
 as a distributed BFS on the BlueGene/L architecture.
 The algorithm takes advantage of the architecture’s structure to develop
 efficient inter-processor communication, which is generally the bottleneck
 in distributed systems.
 Our implementation uses the techniques described in the paper to develop
 our parallel version of the algorithm, but with modifications that make
 more sense for working on a shared memory machine.
 
\end_layout

\begin_layout Standard
The primary difference between our implementation and the method used by
 the paper is how it transmits neighbor nodes to other threads.
 While a thread is executing the breadth first search, it may come across
 nodes that it does not own when searching adjacent nodes.
 The original paper solves this problem by having each thread create lists
 of neighboring nodes that belong to other processes and send them over
 a network to their respective processes and wait to receive lists from
 other processes.
 This sending and receiving of node lists forces the processes to need to
 wait for each other before descending into the next level.
\end_layout

\begin_layout Standard
Our implementation uses the same general methodology of partitioning the
 graph, but without the overhead of a network to perform on, we decided
 that creating queues for each thread, and enqueueing nodes as they were
 found made a lot more sense.
 This way each thread does not have to wait for all other threads to finish
 before searching the next depth level.
 The tradeoff is that the path found may not be the shortest possible path
 to a node and the path found will depend on the scheduler.
\end_layout

\begin_layout Standard
The algorithm starts by partitioning the graph equally between the available
 threads.
 All of the vertices will be assigned an ID indicating which thread is responsib
le for searching it.
 One node will be marked as depth zero.
 This marks the starting node for the search, and is enqueued into the queue
 of its owner.
 Each thread takes the partitioned graph as input of size 
\begin_inset Formula $n/p$
\end_inset

.
 (Where ‘
\begin_inset Formula $n$
\end_inset

’ is the number of vertices in the graph, and ‘
\begin_inset Formula $p$
\end_inset

’ is the number of threads.) The algorithm works by dequeuing a vertex 
\begin_inset Formula $v_{1}$
\end_inset

, and enqueuing its neighbors 
\begin_inset Formula $v'_{1}\rightarrow v'_{k}$
\end_inset

 into the local queues of the thread it belongs to.
 This process is repeated until all queues are empty.
 This modified version is fully illustrated as Algorithm 2.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
small
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Distributed Breadth First expansion with 1D Partitioning
\begin_inset CommandInset citation
LatexCommand cite
key "Yoo:2005:SDP:1105760.1105790"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\textrm{Initialize}\ L_{v_{s}}\left(v\right)=\begin{cases}
0, & v=v_{s},\textrm{where}\ v_{s}\ \textrm{is\ a\ source}\\
\infty & \textrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{for}\ l\ =0\ to\ \infty\ \mathbf{do}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ F\ \leftarrow\ \left\{ v\mid L_{v_{s}}\left(v\right)=l\right\} ,\ \textrm{the\ set\ of\ local\ vertices\ with\ level}\ l$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{if}\ F\ =\ \emptyset\ \textrm{for\ all\ processors}\ \mathbf{then}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \textrm{Terminate\ main\ loop}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{end\ if}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ N\ \leftarrow\ \left\{ \textrm{neighbors\ of\ vertices\ in}\ F\ \left(\textrm{not\ necessarily\ local}\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{for\ all}\ \textrm{processors}\ q\ \mathbf{do}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ N_{q}\ \leftarrow\ \left\{ \textrm{vertices\ in}\ N\ \textrm{owned\ by\ processor}\ q\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \mathbf{Send}\ N_{q}\ \textrm{to\ processor}\ q$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \mathbf{Receive}\ \bar{N}_{q}\ \textrm{from\ processor}\ q$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{end\ for}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \bar{N\ }\leftarrow\ \bigcup_{q}\bar{N}_{q}\ \left(\textrm{The}\ \bar{N}_{q}\ m\textrm{ay\ overlap}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{for}\ v\ \in\bar{N}\ \textrm{and}\ L_{v_{s}}\left(v\right)\ =\ \infty\ \mathbf{do}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ L_{v_{s}}\left(v\right)\ \leftarrow\ l\ +\ 1$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \mathbf{end\ for}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathbf{end\ for}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Modified Breadth First search with 1D Partitoning
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

subgraph<Vertex>[numVerts/numThreads]
\end_layout

\begin_layout Plain Layout

subgraph[k].level = 0
\end_layout

\begin_layout Plain Layout

localQueue[numThreads]
\end_layout

\begin_layout Plain Layout

bfs(subGraph, threadID)
\end_layout

\begin_layout Plain Layout

	finishMask |= 1 << threadID
\end_layout

\begin_layout Plain Layout

	for Vertex v in subgraph
\end_layout

\begin_layout Plain Layout

		v.id = threadID
\end_layout

\begin_layout Plain Layout

		if (v.level = 0)
\end_layout

\begin_layout Plain Layout

			localQueue[v.id] = threadID
\end_layout

\begin_layout Plain Layout

	while ( finishMask != currentMask )
\end_layout

\begin_layout Plain Layout

		while ( localQueue[threadID].size > 0 )
\end_layout

\begin_layout Plain Layout

			srcVert = localQueue[threadID].dequeue()
\end_layout

\begin_layout Plain Layout

			for Edge e in srcVert.edges()
\end_layout

\begin_layout Plain Layout

				localQueue[e.dest.id].enqueue(e.dest)
\end_layout

\begin_layout Plain Layout

				currentMask = 0
\end_layout

\begin_layout Plain Layout

		currentMask |= 1 << threadID
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Multi-threaded BFS (MTBFS)
\end_layout

\begin_layout Standard
The MTBFS implementation used for reference in this paper was implemented
 on a Cray MTA-2 multithreaded architecture 
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset

(Reference paper 2).
 Similar to our approach, the algorithm was tested against scale-free graphs.
 When tested with a graph containing 400 million nodes, a 40 processor system
 showed the multi-threaded algorithm to have a system speedup of about 30
 times over the sequential implementation.
\end_layout

\begin_layout Standard
The algorithm takes in a graph with source node s, and returns a shortest-path
 array d such that d[v] contains the length of the shortest path from source
 node s to destination node v, where v is a node in the graph.
 The algorithm uses the standard approach for implementing a sequential
 BFS where you start by adding the source node to a queue, then continue
 looping until the queue is empty.
 Each iteration dequeues the first node, finds it’s neighboring nodes, and
 adds all unvisited neighbors to the queue.
 The main difference is that looping through the queue and through the neighbori
ng nodes is done in parallel.
 In detail, the algorithm works as shown in Algorithm 3.
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Level-synchronized Parallel BFS
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $for\ all\_v\ \in\ V\ in\ parallel\ do$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ d\left[v\right]\ \leftarrow\ -1;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $d\left[s\right]\ \leftarrow\ 0;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Q\ \leftarrow\ \phi;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $Enqueue\ s\ \leftarrow Q;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $while\ Q\ \neq\ \phi\ do$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ for\ all\ u\ \in\ Q\ in\ parallel\ do$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ Delete\ u\ \leftarrow\ Q;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ for\ each\ v\ adjacent\ to\ u\ in\ parallel\ do$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \ \ \ if\ d\left[v\right]\ =\ -1\ then$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ d\left[v\right]\ \leftarrow\ d\left[u\right]\ +\ 1;$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\ \ \ \ \ \ \ \ \ \ \ \ Enqueue\ v\ \leftarrow\ Q;$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This algorithm takes full advantage of the Cray MTA-2 system’s architecture
 by using its fine-grained parallelism and zero-overhead synchronization
 while looping through the queue and looping over each node’s set of neighbors.
 This multi-threaded BFS technique implemented on the Cray MTA-2 hardware
 architecture design offers a considerable speedup advantage over any sequential
 implementation of BFS on graphs of similar size.
\begin_inset CommandInset citation
LatexCommand cite
key "DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity"

\end_inset


\end_layout

\begin_layout Standard
MTBS has been implemented using nested Parallel.ForEach commands on methods
 that perform the functions highlighted above.
 Our implementation is significantly slower than the version implemented
 on the Cray MTA-2 as the nested parallelization limits the performance
 of the algorithm.
 The parallelization of the edges is responsible for most of the performance
 degradation as the workload of collecting adjacent edges is a relatively
 small.
\end_layout

\begin_layout Subsection*
Level Synchronous BFS (LSBFS)
\end_layout

\begin_layout Standard
The LSBFS algorithm uses level synchronization to keep the processing of
 nodes in order.
 A level property with an initial value of infinity is applied to each of
 the vertices in a graph.
 This property represents the distance a given vertex is away from root
 node.
 When the LSBFS starts, it sets the level of the root node to zero (0) and
 adds the root node to the list of visited nodes.
 Then for each iteration of the breadth first search, all nodes at the current
 level are searched in parallel.
 For each vertex in the current level, all of the vertex’s neighbors are
 obtained and visited.
 For every visited vertex, the level property is set to the current level
 plus one (level + 1).
 After all the neighbors have been visited, the current level counter is
 incremented and all the neighboring nodes we just visited are the next
 set of nodes to continue searching on.
 All threads will execute this task in parallel.
\end_layout

\begin_layout Standard
The bottleneck in this algorithm comes from the fact that a finished thread
 must wait until all other threads finish their portion of the search at
 the current level.
 This is because all threads operate on a single level at a time.
 A general observation is that the number of nodes increases at higher levels
 of the graph.
 The algorithm benefits from this property as the parallel threads have
 more nodes to execute on as the level increases.
 However, another drawback of this method is that the algorithm does not
 take full advantage of breadth-first search properties.
 It would benefit from a partitioning scheme that allowed for multiple threads
 to operate on subgraphs of connected vertices.
 According to the parallel exploration paper
\begin_inset CommandInset citation
LatexCommand cite
key "EfficientparallelGraphExplorationOnMultiCoreCPUAndGPU"

\end_inset

, the algorithm still performs well in real-world systems despite it’s synchroni
zation overhead.
\end_layout

\begin_layout Section
Experimental Results
\end_layout

\begin_layout Standard
Our experiments were implemented on an Intel i7 system with 4 cores.
 Our first benchmark included an import of a FaceBook social network with
 7737 nodes and 12,694 edges.
 The second benchmark is a scale free dataset based on internet architecture
 with 124,651 nodes and 207,214 edges.
 The experiments were run multiple times over 2, 4, 6, and 8 threads.
\end_layout

\begin_layout Standard
Our experimental results show that the PPBFS algorithm has a 62% improvement
 over the performance of the sequential algorithm when it is executed on
 the larger scale free graph with four threads.
 The algorithm was not able to run with two threads, and the execution time
 in this case is marked as zero in our results.
\end_layout

\begin_layout Standard
The PPBFS algorithm also does not perform nearly as well on the smaller
 facebook graph.
 In order to achieve the performance benefits of partitioning the graph,
 the number of nodes must be sufficiently high to amortize the penalty of
 the graph partitioning process.
 
\end_layout

\begin_layout Standard
The MTBFS and LSBFS algorithms do not perform as well as the sequential
 BFS algorithm, but the performance gap narrows as the number of threads
 increases.
 These algorithms performance results are based on the balancing of work
 among the threads, and both graphs show good performance until 8 threads.
 With 8 threads, MTBFS continues its performance improvement, but LSBFS’s
 performance starts to decrease.
 This is likely because the overhead of the additional threads is no longer
 contributing to a balanced workload.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotsset{} 
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

	title=Scale-Free Graph,
\end_layout

\begin_layout Plain Layout

	xtick=data,
\end_layout

\begin_layout Plain Layout

	clip=false,
\end_layout

\begin_layout Plain Layout

	nodes near coords,     %Adds node at top of bar indicating height
\end_layout

\begin_layout Plain Layout

	%xbar=6pt,              %Specifies filled bar
\end_layout

\begin_layout Plain Layout

	%ybar,
\end_layout

\begin_layout Plain Layout

	ymin=0,                %Forces bars to snap to bottom.
\end_layout

\begin_layout Plain Layout

	enlarge x limits=0.25, %Helps with spacing between bars
\end_layout

\begin_layout Plain Layout

	%ybar=0pt,
\end_layout

\begin_layout Plain Layout

	%bar width=30pt,
\end_layout

\begin_layout Plain Layout

	ylabel={Time (ms)},
\end_layout

\begin_layout Plain Layout

	xlabel={Threads},
\end_layout

\begin_layout Plain Layout

	%x tick label style={rotate=45, anchor=east},
\end_layout

\begin_layout Plain Layout

	symbolic x coords={2, 4, 6, 8}
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,302) (4,302) (6,302) (8,302)}; %Sequential
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,734) (4,449) (6,370) (8,295)}; %MTBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,634) (4,458) (6,327) (8,348)}; %LSBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,206) (4,185) (6,230) (8,303)}; %PPBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
legend{Sequential, MTBFS, LSBFS, PPBFS}
\end_layout

\begin_layout Plain Layout


\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfplotsset{} 
\backslash
begin{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
begin{axis}[
\end_layout

\begin_layout Plain Layout

	title=Facebook,
\end_layout

\begin_layout Plain Layout

	xtick=data,
\end_layout

\begin_layout Plain Layout

	clip=false,
\end_layout

\begin_layout Plain Layout

	nodes near coords,     %Adds node at top of bar indicating height
\end_layout

\begin_layout Plain Layout

	%xbar=6pt,              %Specifies filled bar
\end_layout

\begin_layout Plain Layout

	%ybar,
\end_layout

\begin_layout Plain Layout

	ymin=0,                %Forces bars to snap to bottom.
\end_layout

\begin_layout Plain Layout

	enlarge x limits=0.25, %Helps with spacing between bars
\end_layout

\begin_layout Plain Layout

	%ybar=0pt,
\end_layout

\begin_layout Plain Layout

	%bar width=30pt,
\end_layout

\begin_layout Plain Layout

	ylabel={Time (ms)},
\end_layout

\begin_layout Plain Layout

	xlabel={Threads},
\end_layout

\begin_layout Plain Layout

	%x tick label style={rotate=45, anchor=east},
\end_layout

\begin_layout Plain Layout

	symbolic x coords={2, 4, 6, 8}
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,22) (4,24) (6,23) (8, 22)}; %Sequential
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,76) (4,68) (6,54) (8, 31)}; %MTBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,63) (4,45) (6,40) (8, 41)}; %LSBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
addplot plot coordinates {(2,17) (4,37) (6,62) (8,189)}; %PPBFS
\end_layout

\begin_layout Plain Layout

	
\backslash
legend{Sequential, MTBFS, LSBFS, PPBFS}
\end_layout

\begin_layout Plain Layout


\backslash
end{axis}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
Our experimental results show that PPBFS algorthm can improve the performance
 of scale free graph traversals, with a sufficiently high number of nodes,
 and a balanced number of threads.
 The algorithm consistently has the best performance when it uses four threads,
 and if the dataset is large enough to encourage this type of parallel graph
 analysis it can perform very well.
 The MTBFS and LSBFS algorithms have generally lower performance than their
 sequential counterpart, but this was partially expected as it has been
 reported that scale free graphs don’t benefit much from these simpler forms
 of parallelization.Our implementation of PPBFS outperforms the other algorithms
 we used as benchmarks of parallel BFS performance, making it a suitable
 choice for scale free graph analysis.
 
\end_layout

\begin_layout Section
Challenges
\end_layout

\begin_layout Standard
Many benchmark datasets contain graphs with disjoint sets of vertices.
 Disjoint graphs with BFS won’t allow the algorithm to visit all the nodes.
 The GDBench tool that we had intended to use for the production of substantiall
y large datasets would produce disjoint graphs with roughly half the nodes
 in each set.
 This made the datasets produced nearly unusable as only half the graph
 could be traversed by the algorithms.
 
\end_layout

\begin_layout Standard
These datasets may have been usable, but the NodeXL architecture we implemented
 becomes sensitive to the amount of memory used as the number of nodes increases
 above 100,000.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
There are a few minor optimizations we would like to focus on for the future
 works of this project.
 First, we would like to compare the differences in performance between
 restricting the algorithm to visiting nodes on a level synchronous bases,
 versus running a level asynchronous version.
 The asynchronous version would have the possibility of visiting nodes multiple
 times, but it would eliminate the overhead of threads needing to synchronize
 their execution after each level.
 Another small optimization we would like to implement is attempting to
 use array based queues.
 The size of the array for the queue could be easily determined by observing
 the number of nodes rationed to each partition of the graph.
 This would give us the benefit of spatial locality over the current list
 based queue that is used.
\end_layout

\begin_layout Standard
We would also like to use larger graphs to test our algorithm.
 We believe the algorithm would benefit from larger graphs since the parallelism
 could take full advantage of the larger range of nodes.
 As we observed from our test results, sometimes it’s beneficial to use
 a sequential approach over a parallel approach, and sometimes it’s beneficial
 to use a partitioned approach over a full graph search.
 With this in mind, we would like to optimize our implementation by taking
 a hybrid approach to determine which algorithm would be best to use based
 on the graph provided and the capabilities of the system which is being
 used to run the search.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "C:/Bibtex/AScalableDistributedParallelBreadth-FirstSearchAlgorithm,C:/Bibtex/DesigningMultithreadedAlgorithmsForBreadthFirstSearchandStConnectivity,C:/Bibtex/ParallelBreadthFirstSearchOnDistributedMemorySystems,C:/Bibtex/ScalingTechniquesForMassiveScaleFreeGraphsInDistributedMemory,C:/Bibtex/AnalyzingSocialMediaNetworksWithNodeXL,C:/Bibtex/EfficientparallelGraphExplorationOnMultiCoreCPUAndGPU,C:/Bibtex/BenchmarkingDatabaseSystemsForSocialNetworkApplications"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
